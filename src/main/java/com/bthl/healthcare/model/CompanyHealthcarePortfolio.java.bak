/**
 * File: /var/www/davestj.com/bthl-hc/src/main/java/com/bthl/healthcare/model/CompanyHealthcarePortfolio.java
 * Author: davestj (David St John)
 * Date: 2025-07-16
 * Purpose: Company Healthcare Portfolio entity for managing company insurance portfolios
 * Description: I designed this entity to represent a company's complete healthcare coverage portfolio
 *              for a specific policy year, including all selected plans, broker relationships,
 *              and comprehensive portfolio analytics.
 * 
 * Changelog:
 * 2025-07-16: Initial creation of CompanyHealthcarePortfolio entity with comprehensive portfolio management
 * 
 * Git Commit: git commit -m "feat: add CompanyHealthcarePortfolio entity for complete portfolio management"
 * 
 * Next Dev Feature: Add portfolio optimization algorithms and renewal prediction analytics
 * TODO: Implement automated renewal workflows and cost trend analysis
 */

package com.bthl.healthcare.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.hibernate.annotations.UuidGenerator;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.ChronoUnit;import java.time.LocalDateTime;
import java.util.*;

/**
 * I created this CompanyHealthcarePortfolio entity to represent a company's
 * complete healthcare coverage for a specific policy year. I've designed it
 * to track all aspects of the company's insurance program and employee coverage.
 */
@Entity
@Table(name = "company_healthcare_portfolios", indexes = {
    @Index(name = "idx_portfolios_company", columnList = "company_id"),
    @Index(name = "idx_portfolios_broker", columnList = "broker_id"),
    @Index(name = "idx_portfolios_year", columnList = "policy_year"),
    @Index(name = "idx_portfolios_status", columnList = "status")
})
@EntityListeners(AuditingEntityListener.class)
public class CompanyHealthcarePortfolio {

    @Id
    @UuidGenerator
    @Column(name = "id", updatable = false, nullable = false)
    public UUID id;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "company_id", nullable = false)
    public Company company;

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "broker_id")
    public InsuranceBroker broker;

    @NotBlank(message = "Portfolio name is required")
    @Size(max = 255, message = "Portfolio name must not exceed 255 characters")
    @Column(name = "portfolio_name", nullable = false, length = 255)
    public String portfolioName;

    @NotNull(message = "Policy year is required")
    @Min(value = 2020, message = "Policy year must be 2020 or later")
    @Max(value = 2030, message = "Policy year must not exceed 2030")
    @Column(name = "policy_year", nullable = false)
    public Integer policyYear;

    @NotNull(message = "Effective date is required")
    @Column(name = "effective_date", nullable = false)
    public LocalDate effectiveDate;

    @NotNull(message = "Renewal date is required")
    @Column(name = "renewal_date", nullable = false)
    public LocalDate renewalDate;

    @DecimalMin(value = "0.00", message = "Total premium must be non-negative")
    @DecimalMax(value = "99999999999.99", message = "Total premium must not exceed $99,999,999,999.99")
    @Column(name = "total_premium", precision = 15, scale = 2)
    public BigDecimal totalPremium;

    @DecimalMin(value = "0.00", message = "Employee contribution percentage must be non-negative")
    @DecimalMax(value = "100.00", message = "Employee contribution percentage must not exceed 100%")
    @Column(name = "employee_contribution_percentage", precision = 5, scale = 2)
    public BigDecimal employeeContributionPercentage;

    @Min(value = 0, message = "Total employees covered must be non-negative")
    @Column(name = "total_employees_covered")
    public Integer totalEmployeesCovered;

    @Min(value = 0, message = "Total dependents covered must be non-negative")
    @Column(name = "total_dependents_covered")
    public Integer totalDependentsCovered;

    @Column(name = "wellness_program", nullable = false)
    public Boolean wellnessProgram = false;

    @DecimalMin(value = "0.0000", message = "Wellness discount must be non-negative")
    @DecimalMax(value = "1.0000", message = "Wellness discount must not exceed 100%")
    @Column(name = "wellness_discount", precision = 5, scale = 4)
    public BigDecimal wellnessDiscount;

    @Column(name = "claims_history", columnDefinition = "jsonb")
    public Map<String, Object> claimsHistory = new HashMap<>();

    @Column(name = "risk_assessment", columnDefinition = "jsonb")
    public Map<String, Object> riskAssessment = new HashMap<>();

    @Pattern(regexp = "^(ACTIVE|INACTIVE|RENEWAL|TERMINATED|PENDING)$", message = "Status must be ACTIVE, INACTIVE, RENEWAL, TERMINATED, or PENDING")
    @Column(name = "status", length = 20)
    public String status = "PENDING";

    @Size(max = 2000, message = "Notes must not exceed 2000 characters")
    @Column(name = "notes", columnDefinition = "TEXT")
    public String notes;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    public LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    public LocalDateTime updatedAt;

    @CreatedBy
    @Column(name = "created_by")
    public UUID createdBy;

    @LastModifiedBy
    @Column(name = "updated_by")
    public UUID updatedBy;

    @OneToMany(mappedBy = "portfolio", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    public Set<PortfolioPlan> portfolioPlans = new HashSet<>();

    // I implement default constructor for JPA
    public CompanyHealthcarePortfolio() {}

    // I create a comprehensive constructor for portfolio creation
    public CompanyHealthcarePortfolio(Company company, String portfolioName, Integer policyYear,
                                    LocalDate effectiveDate, LocalDate renewalDate, InsuranceBroker broker) {
        this.company = company;
        this.portfolioName = portfolioName;
        this.policyYear = policyYear;
        this.effectiveDate = effectiveDate;
        this.renewalDate = renewalDate;
        this.broker = broker;
        this.status = "PENDING";
        this.wellnessProgram = false;
    }

    // I implement getter and setter methods following my naming conventions

    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public Company getCompany() {
        return company;
    }

    public void setCompany(Company company) {
        this.company = company;
    }

    public InsuranceBroker getBroker() {
        return broker;
    }

    public void setBroker(InsuranceBroker broker) {
        this.broker = broker;
    }

    public String getPortfolioName() {
        return portfolioName;
    }

    public void setPortfolioName(String portfolioName) {
        this.portfolioName = portfolioName;
    }

    public Integer getPolicyYear() {
        return policyYear;
    }

    public void setPolicyYear(Integer policyYear) {
        this.policyYear = policyYear;
    }

    public LocalDate getEffectiveDate() {
        return effectiveDate;
    }

    public void setEffectiveDate(LocalDate effectiveDate) {
        this.effectiveDate = effectiveDate;
    }

    public LocalDate getRenewalDate() {
        return renewalDate;
    }

    public void setRenewalDate(LocalDate renewalDate) {
        this.renewalDate = renewalDate;
    }

    public BigDecimal getTotalPremium() {
        return totalPremium;
    }

    public void setTotalPremium(BigDecimal totalPremium) {
        this.totalPremium = totalPremium;
    }

    public BigDecimal getEmployeeContributionPercentage() {
        return employeeContributionPercentage;
    }

    public void setEmployeeContributionPercentage(BigDecimal employeeContributionPercentage) {
        this.employeeContributionPercentage = employeeContributionPercentage;
    }

    public Integer getTotalEmployeesCovered() {
        return totalEmployeesCovered;
    }

    public void setTotalEmployeesCovered(Integer totalEmployeesCovered) {
        this.totalEmployeesCovered = totalEmployeesCovered;
    }

    public Integer getTotalDependentsCovered() {
        return totalDependentsCovered;
    }

    public void setTotalDependentsCovered(Integer totalDependentsCovered) {
        this.totalDependentsCovered = totalDependentsCovered;
    }

    public Boolean getWellnessProgram() {
        return wellnessProgram;
    }

    public void setWellnessProgram(Boolean wellnessProgram) {
        this.wellnessProgram = wellnessProgram;
    }

    public BigDecimal getWellnessDiscount() {
        return wellnessDiscount;
    }

    public void setWellnessDiscount(BigDecimal wellnessDiscount) {
        this.wellnessDiscount = wellnessDiscount;
    }

    public Map<String, Object> getClaimsHistory() {
        return new HashMap<>(claimsHistory);
    }

    public void setClaimsHistory(Map<String, Object> claimsHistory) {
        this.claimsHistory = claimsHistory != null ? new HashMap<>(claimsHistory) : new HashMap<>();
    }

    public Map<String, Object> getRiskAssessment() {
        return new HashMap<>(riskAssessment);
    }

    public void setRiskAssessment(Map<String, Object> riskAssessment) {
        this.riskAssessment = riskAssessment != null ? new HashMap<>(riskAssessment) : new HashMap<>();
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getNotes() {
        return notes;
    }

    public void setNotes(String notes) {
        this.notes = notes;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public LocalDateTime getUpdatedAt() {
        return updatedAt;
    }

    public UUID getCreatedBy() {
        return createdBy;
    }

    public UUID getUpdatedBy() {
        return updatedBy;
    }

    public Set<PortfolioPlan> getPortfolioPlans() {
        return new HashSet<>(portfolioPlans);
    }

    public void setPortfolioPlans(Set<PortfolioPlan> portfolioPlans) {
        this.portfolioPlans = portfolioPlans != null ? new HashSet<>(portfolioPlans) : new HashSet<>();
    }

    // I create convenient computed properties for frontend use

    @JsonProperty("displayName")
    public String getDisplayName() {
        String companyName = company != null ? company.getName() : "Unknown Company";
        return companyName + " - " + portfolioName + " (" + policyYear + ")";
    }

    @JsonProperty("totalCovered")
    public Integer getTotalCovered() {
        int employees = totalEmployeesCovered != null ? totalEmployeesCovered : 0;
        int dependents = totalDependentsCovered != null ? totalDependentsCovered : 0;
        return employees + dependents;
    }

    @JsonProperty("averagePremiumPerPerson")
    public BigDecimal getAveragePremiumPerPerson() {
        if (totalPremium == null || getTotalCovered() == 0) return BigDecimal.ZERO;
        return totalPremium.divide(new BigDecimal(getTotalCovered()), 2, java.math.RoundingMode.HALF_UP);
    }

    @JsonProperty("employerContribution")
    public BigDecimal getEmployerContribution() {
        if (totalPremium == null || employeeContributionPercentage == null) return BigDecimal.ZERO;
        BigDecimal employeeContribution = totalPremium.multiply(employeeContributionPercentage.divide(new BigDecimal("100")));
        return totalPremium.subtract(employeeContribution);
    }

    @JsonProperty("employeeContribution")
    public BigDecimal getEmployeeContribution() {
        if (totalPremium == null || employeeContributionPercentage == null) return BigDecimal.ZERO;
        return totalPremium.multiply(employeeContributionPercentage.divide(new BigDecimal("100")));
    }

    @JsonProperty("daysUntilRenewal")
    public Long getDaysUntilRenewal() {
        return renewalDate != null ? java.time.ChronoUnit.DAYS.between(LocalDate.now(), renewalDate) : null;
    }

    @JsonProperty("isActive")
    public boolean getIsActive() {
        return "ACTIVE".equals(status);
    }

    @JsonProperty("isRenewalDue")
    public boolean getIsRenewalDue() {
        return renewalDate != null && renewalDate.isBefore(LocalDate.now().plusDays(90));
    }

    @JsonProperty("planCount")
    public int getPlanCount() {
        return portfolioPlans != null ? portfolioPlans.size() : 0;
    }

    @JsonProperty("dependencyRatio")
    public BigDecimal getDependencyRatio() {
        if (totalEmployeesCovered == null || totalEmployeesCovered == 0) return BigDecimal.ZERO;
        int dependents = totalDependentsCovered != null ? totalDependentsCovered : 0;
        return new BigDecimal(dependents).divide(new BigDecimal(totalEmployeesCovered), 2, java.math.RoundingMode.HALF_UP);
    }

    @JsonProperty("wellnessDiscountAmount")
    public BigDecimal getWellnessDiscountAmount() {
        if (totalPremium == null || wellnessDiscount == null) return BigDecimal.ZERO;
        return totalPremium.multiply(wellnessDiscount);
    }

    @JsonProperty("statusClass")
    public String getStatusClass() {
        return switch (status != null ? status : "PENDING") {
            case "ACTIVE" -> "status-active";
            case "INACTIVE" -> "status-inactive";
            case "RENEWAL" -> "status-renewal";
            case "TERMINATED" -> "status-terminated";
            case "PENDING" -> "status-pending";
            default -> "status-unknown";
        };
    }

    // I implement business logic methods for portfolio management

    public void activate() {
        this.status = "ACTIVE";
    }

    public void deactivate() {
        this.status = "INACTIVE";
    }

    public void markForRenewal() {
        this.status = "RENEWAL";
    }

    public void terminate() {
        this.status = "TERMINATED";
    }

    public void addPlan(PortfolioPlan portfolioPlan) {
        if (portfolioPlan != null) {
            if (portfolioPlans == null) {
                portfolioPlans = new HashSet<>();
            }
            portfolioPlans.add(portfolioPlan);
            portfolioPlan.portfolio = this;
            recalculateTotals();
        }
    }

    public void removePlan(PortfolioPlan portfolioPlan) {
        if (portfolioPlans != null && portfolioPlan != null) {
            portfolioPlans.remove(portfolioPlan);
            portfolioPlan.portfolio = null;
            recalculateTotals();
        }
    }

    public void recalculateTotals() {
        if (portfolioPlans == null || portfolioPlans.isEmpty()) {
            totalEmployeesCovered = 0;
            totalDependentsCovered = 0;
            return;
        }

        int employees = portfolioPlans.stream()
            .mapToInt(pp -> pp.employeesEnrolled != null ? pp.employeesEnrolled : 0)
            .sum();
        
        int dependents = portfolioPlans.stream()
            .mapToInt(pp -> pp.dependentsEnrolled != null ? pp.dependentsEnrolled : 0)
            .sum();

        this.totalEmployeesCovered = employees;
        this.totalDependentsCovered = dependents;
    }

    public void updateClaimsHistory(String period, Object claims) {
        if (period != null && !period.trim().isEmpty()) {
            if (claimsHistory == null) {
                claimsHistory = new HashMap<>();
            }
            claimsHistory.put(period, claims);
        }
    }

    public void updateRiskAssessment(String factor, Object assessment) {
        if (factor != null && !factor.trim().isEmpty()) {
            if (riskAssessment == null) {
                riskAssessment = new HashMap<>();
            }
            riskAssessment.put(factor, assessment);
        }
    }

    public boolean hasCompleteInformation() {
        return company != null &&
               portfolioName != null && !portfolioName.trim().isEmpty() &&
               policyYear != null &&
               effectiveDate != null &&
               renewalDate != null &&
               totalPremium != null &&
               portfolioPlans != null && !portfolioPlans.isEmpty();
    }

    // I implement equals and hashCode based on UUID
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        CompanyHealthcarePortfolio portfolio = (CompanyHealthcarePortfolio) obj;
        return Objects.equals(id, portfolio.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "CompanyHealthcarePortfolio{" +
               "id=" + id +
               ", company=" + (company != null ? company.getName() : "null") +
               ", portfolioName='" + portfolioName + '\'' +
               ", policyYear=" + policyYear +
               ", status='" + status + '\'' +
               ", totalCovered=" + getTotalCovered() +
               ", planCount=" + getPlanCount() +
               ", createdAt=" + createdAt +
               '}';
    }
}
